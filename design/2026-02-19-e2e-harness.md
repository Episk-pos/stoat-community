# Proposal: Robust E2E Test Harness for Stoat

**Date:** 2026-02-19  
**Status:** Draft  
**Tracking Issue:** `stoat-community-1et.1`

## 1. Objective
Establish a reliable, deterministic, and fast End-to-End (E2E) testing framework for Stoat's frontend, specifically addressing the complexity of Voice/Video (RTC) features. The goal is to verify UI behavior without depending on flaky or expensive real-world backend infrastructure during CI runs.

## 2. Core Architecture

### 2.1 Framework: Playwright
We will standardize on **Playwright** (already present in `packages/client`). It offers superior handling of modern web features, isolation, and debugging tools (traces, video).

### 2.2 The "Mock Mode" Strategy
RTC tests are notoriously flaky when testing against real servers due to network jitter and state synchronization delays. We propose a **Client-Side Mocking** approach.

1.  **Build Flag:** Introduce a `VITE_MOCK_RTC=true` environment variable.
2.  **Mock Injection:**
    *   When this flag is active, the `Voice` class (in `packages/client/components/rtc/state.tsx`) will bypass the real `livekit-client` connection logic.
    *   Instead, it will instantiate a `MockRoom` adapter.
3.  **Control Surface:**
    *   The `MockRoom` will expose a global control API on the window object (e.g., `window.__STOAT_TEST_CONTROLLER__`).
    *   Playwright tests will drive this controller to simulate events.

### 2.3 Workflow Example (Spotlight Feature)
Instead of waiting for a real user to speak, the test will:
1.  Load the app with `VITE_MOCK_RTC=true`.
2.  Join a voice channel (which instantly resolves to "Connected" in mock mode).
3.  Execute:
    ```ts
    await page.evaluate(() => {
      window.__STOAT_TEST_CONTROLLER__.addRemoteParticipant("user-2", { camera: true });
      window.__STOAT_TEST_CONTROLLER__.simulateActiveSpeaker(["user-2"]);
    });
    ```
4.  Assert: Verify the UI updates to spotlight "user-2".

## 3. Implementation Plan

### 3.1 `MockLiveKit` Layer
We need to implement a partial mock of the LiveKit SDK interfaces that `solid-livekit-components` consumes.
*   **`MockRoom`**: Emits standard events (`activeSpeakersChanged`, `trackSubscribed`).
*   **`MockParticipant`**: Manages mock track publications.
*   **`MockTrack`**: Returns dummy `MediaStreamTrack` objects (using Canvas/WebAudio APIs to generate distinct patterns/beeps if needed for visual regression, or just black frames).

### 3.2 Test Helper Library
Create a `packages/client/e2e/helpers/rtc.ts` library to abstract the `page.evaluate` calls.
*   `rtc.joinChannel(channelId)`
*   `rtc.addParticipant(id, name)`
*   `rtc.startSpeaking(id)`
*   `rtc.startScreenshare(id)`

### 3.3 CI/CD Integration
*   **GitHub Actions:** Update `build-and-test.yml` to run these tests.
*   **Sharding:** If tests grow slow, use Playwright sharding.
*   **Artifacts:** Always upload traces on failure.

## 4. Benefits
*   **Determinism:** 100% reproducible states. No network flakes.
*   **Speed:** No waiting for connection establishment or media negotiation.
*   **Cost:** No need to spin up ephemeral LiveKit server instances for every PR.

## 5. Open Questions
*   **Visual Regression:** Do we need screenshot testing for the video grid? (Recommendation: Yes, but scoped to layout correctness, not video content).
*   **Audio/Video Pipelines:** Do we need to verify that *real* media flows? (Recommendation: Keep one "smoke test" against a real dev server, but run 99% of logic tests against mocks).
